# 주요 알고리즘 코드 with JAVA

이 저장소는 자바로 구현된 주요 알고리즘들의 모음입니다.

## 목차

- [BFS & DFS](#bfs--dfs)
- [그래프](#그래프)
- [기타](#기타)
- [다이나믹 프로그래밍](#다이나믹-프로그래밍)
- [수열](#수열)
- [순열 & 조합](#순열--조합)
- [이진 탐색](#이진-탐색)
- [정렬](#정렬)
- [최단 경로](#최단-경로)
- [트리](#트리)

---

## BFS & DFS

### BFS (너비 우선 탐색)
- **설명**: 그래프를 탐색할 때 같은 레벨의 노드들을 먼저 탐색하는 알고리즘
- **구현**: 큐(Queue) 자료구조를 사용하여 구현
- **시간 복잡도**: O(V + E) (V: 노드 개수, E: 간선 개수)
- **특징**: 시작 노드로부터 가까운 노드부터 탐색하므로 최단 경로를 찾을 때 유용

### DFS (깊이 우선 탐색)
- **설명**: 그래프를 탐색할 때 한 경로를 끝까지 탐색한 후 다음 경로를 탐색하는 알고리즘
- **구현**: 재귀 함수를 사용하여 구현
- **시간 복잡도**: O(V + E) (V: 노드 개수, E: 간선 개수)
- **특징**: 모든 경로를 탐색해야 할 때 유용

---

## 그래프

### 그래프 표현 방식

#### 인접 리스트 방식
- **설명**: 각 노드에 연결된 노드들을 리스트로 저장하는 방식
- **장점**: 메모리 사용량이 적음 (간선 개수에 비례)
- **단점**: 특정 두 노드 간 연결 여부 확인이 느림 (O(V))
- **사용 시기**: DFS, BFS 등 특정 노드와 연결된 모든 인접 노드를 순회해야 하는 경우

#### 인접 행렬 방식
- **설명**: 2차원 배열을 사용하여 노드 간 연결 관계를 저장하는 방식
- **장점**: 특정 두 노드 간 연결 여부 확인이 빠름 (O(1))
- **단점**: 메모리 사용량이 많음 (O(V²))
- **사용 시기**: 노드 간 연결 여부를 자주 확인해야 하는 경우

### 서로소 집합 (Union-Find)
- **설명**: 여러 노드가 서로 같은 집합에 속하는지 판단하는 자료구조
- **연산**:
  - `find`: 특정 노드의 루트 노드를 찾는 연산 (경로 압축 최적화 포함)
  - `union`: 두 노드가 속한 집합을 합치는 연산
- **시간 복잡도**: 거의 O(1) (경로 압축 최적화 사용 시)
- **활용**: 크루스칼 알고리즘, 사이클 판별 등

### 위상 정렬
- **설명**: 방향 그래프의 모든 노드를 방향성에 거스르지 않도록 순서대로 나열하는 알고리즘
- **조건**: 사이클이 없는 방향 그래프(DAG)에서만 사용 가능
- **구현**: 진입 차수(indegree)를 이용한 큐 기반 알고리즘
- **시간 복잡도**: O(V + E) (V: 노드 개수, E: 간선 개수)
- **활용**: 작업 스케줄링, 의존성 해결 등

### 크루스칼 알고리즘
- **설명**: 최소 신장 트리(Minimum Spanning Tree, MST)를 구하는 알고리즘
- **최소 신장 트리**: 모든 노드를 포함하면서 사이클이 존재하지 않는 부분 그래프 중 간선의 가중치 합이 최소인 트리
- **구현**:
  1. 간선을 비용 오름차순으로 정렬
  2. 사이클이 발생하지 않는 경우에만 간선을 선택 (Union-Find 사용)
- **시간 복잡도**: O(E log E) (간선 정렬 시간)
- **활용**: 네트워크 설계, 도로 건설 등

---

## 기타

### 소수 찾기 (에라토스테네스의 체)
- **설명**: 주어진 범위 내의 모든 소수를 효율적으로 찾는 알고리즘
- **원리**: 2부터 시작하여 각 수의 배수를 제거하는 방식
- **최적화**: n의 제곱근까지만 확인하면 됨
- **시간 복잡도**: O(n log log n)
- **활용**: 소수 판별, 소수 개수 구하기 등

---

## 다이나믹 프로그래밍

- **설명**: 큰 문제를 작은 문제로 나누고, 같은 문제라면 한 번씩만 풀어 문제를 효율적으로 해결하는 알고리즘 기법
- **조건**:
  1. 큰 문제를 작은 문제로 나눌 수 있다
  2. 작은 문제에서 구한 정답을 그것을 포함하는 큰 문제에서도 동일하다
- **예시**: 피보나치 수열 계산 - 시간 복잡도 O(N)

### 메모이제이션 기법 (캐싱)
- **설명**: 한 번 구한 결과를 메모리 공간에 메모해두고 같은 식을 다시 호출하면 메모한 결과를 그대로 가져오는 기법
- **활용**: 탑다운 방식에서 사용

### 분할 정복 알고리즘과의 차이
- **분할 정복**: 문제들이 서로 영향을 미치지 않음 (예: 퀵 정렬)
- **다이나믹 프로그래밍**: 문제들이 서로 영향을 미침 (점화식 존재)

### 구현 방식

#### 탑다운 방식 (재귀)
- **설명**: 재귀 함수를 이용해 큰 문제를 해결하기 위해 작은 문제를 호출하는 방식
- **예시**: `피보나치수열_재귀.java`
- **특징**: 메모이제이션 사용

#### 바텀업 방식 (반복문)
- **설명**: 반복문을 이용해 작은 문제부터 차근차근 답을 도출하는 방식
- **예시**: `피보나치수열_반복문.java`
- **특징**: DP 테이블 사용, 일반적으로 탑다운 방식보다 성능이 좋음

---

## 수열

### 가장 긴 증가하는 부분 수열 (LIS)
- **설명**: 주어진 수열에서 증가하는 부분 수열 중 가장 긴 것의 길이를 구하는 알고리즘
- **구현**: 다이나믹 프로그래밍 사용
- **점화식**: `dp[i] = max(dp[i], dp[j] + 1) if arr[i] > arr[j] (0 <= j < i)`
- **시간 복잡도**: O(N²)
- **활용**: 최장 증가 부분 수열 문제

### 부분 연속 수열 (투 포인터)
- **설명**: 목표 합을 만족하는 부분 연속 수열의 개수를 구하는 알고리즘
- **구현**: 두 개의 포인터(start, end)를 이용하여 구간을 조절
- **시간 복잡도**: O(N)
- **활용**: 연속된 구간의 합 문제, 부분 배열 문제 등

---

## 순열 & 조합

### 순열
- **설명**: N개 중 M개를 선택하여 순서를 고려하여 나열하는 경우의 수
- **구현**: DFS, 재귀, 백트래킹 사용
- **특징**: 순서가 중요함 (예: [1, 2]와 [2, 1]은 다름)
- **활용**: 암호 생성, 순서가 중요한 경우의 수 문제

### 조합
- **설명**: N개 중 M개를 선택하는 경우의 수 (순서 고려 안 함)
- **구현**: DFS, 재귀, 백트래킹 사용 (start 인덱스 활용)
- **특징**: 순서가 중요하지 않음 (예: [1, 2]와 [2, 1]은 같음)
- **활용**: 팀 구성, 선택 문제 등

---

## 이진 탐색

### 이진 탐색
- **설명**: 정렬된 배열에서 타겟을 찾는 검색 알고리즘
- **원리**: 배열의 중간값과 타겟을 비교하여 탐색 범위를 절반씩 줄여나감
- **구현 방식**:
  - 반복문 사용
  - 재귀 함수 사용
- **시간 복잡도**: O(log N)
- **전제 조건**: 배열이 정렬되어 있어야 함
- **활용**: 정렬된 데이터에서 빠른 검색, 파라메트릭 서치 등

---

## 정렬

### 거품 정렬 (Bubble Sort)
- **설명**: 맨 앞에서부터 현재 원소와 다음 원소를 비교하여 정렬하는 알고리즘
- **특징**: 맨 뒤쪽부터 하나씩 정렬됨
- **시간 복잡도**: O(N²)
- **공간 복잡도**: O(1)
- **안정 정렬**: 예

### 선택 정렬 (Selection Sort)
- **설명**: 가장 작은 원소를 선택해 맨 앞에 있는 원소와 바꾸는 정렬
- **특징**: 현재 데이터의 정렬 상태와 상관없이 무조건 모든 원소를 비교
- **시간 복잡도**: O(N²) (최선, 평균, 최악 모두 동일)
- **공간 복잡도**: O(1)
- **안정 정렬**: 아니오

### 삽입 정렬 (Insertion Sort)
- **설명**: 원소를 적절한 위치에 삽입하는 정렬
- **특징**: 
  - 선택 정렬보다 빠름
  - 거의 정렬된 경우 매우 효율적
- **시간 복잡도**: 
  - 최선: O(N) (거의 정렬된 경우)
  - 평균, 최악: O(N²)
- **공간 복잡도**: O(1)
- **안정 정렬**: 예

### 병합 정렬 (Merge Sort)
- **설명**: 배열을 반으로 나누어 정렬한 후 병합하는 분할 정복 알고리즘
- **특징**:
  - 안정 정렬
  - 입력값에 관계없이 성능이 일정함
  - 추가 메모리 공간 필요
- **시간 복잡도**: O(N log N) (최선, 평균, 최악 모두 동일)
- **공간 복잡도**: O(N)
- **안정 정렬**: 예

### 퀵 정렬 (Quick Sort)
- **설명**: 기준 데이터(피벗)를 설정하고, 기준보다 큰 데이터와 작은 데이터의 위치를 교환하는 분할 정복 알고리즘
- **특징**:
  - 피벗 선택이 성능에 큰 영향
  - 일반적으로 가장 빠른 정렬 알고리즘
- **시간 복잡도**:
  - 평균: O(N log N)
  - 최악: O(N²) (이미 정렬된 경우)
- **공간 복잡도**: O(log N)
- **안정 정렬**: 아니오

### 계수 정렬 (Counting Sort)
- **설명**: 각 원소가 몇 번 등장하는지 세어서 정렬하는 알고리즘
- **조건**:
  - 최대 크기가 제한되어 있어야 함
  - 0 이상의 정수여야 함
  - 가장 큰 수와 가장 작은 수의 차이가 1,000,000을 넘지 않을 때 효과적
- **시간 복잡도**: O(N + K) (K: 최대값)
- **공간 복잡도**: O(K)
- **안정 정렬**: 예

---

## 최단 경로

### 다익스트라 알고리즘
- **설명**: 특정 노드에서 다른 모든 노드로의 최단 경로를 구하는 알고리즘
- **조건**: 음의 간선이 없는 그래프에서만 사용 가능
- **구현**: 우선순위 큐(Priority Queue)를 사용한 개선된 버전
- **시간 복잡도**: O(E log V) (E: 간선 개수, V: 노드 개수)
- **활용**: 한 지점에서 다른 모든 지점까지의 최단 경로 문제

### 플로이드 워셜 알고리즘
- **설명**: 모든 노드 간의 최단 경로를 구하는 알고리즘
- **구현**: 3중 반복문을 이용한 다이나믹 프로그래밍
- **점화식**: `f(a, b) = min(f(a, b), f(a, i) + f(i, b))`
- **시간 복잡도**: O(V³) (V: 노드 개수)
- **활용**: 모든 지점에서 모든 지점까지의 최단 경로 문제

---

## 트리

### LCA (최소 공통 조상)
- **설명**: 트리에서 두 노드의 공통 조상 중 가장 가까운 조상을 찾는 알고리즘
- **구현**: 
  - 각 노드의 깊이(depth) 계산
  - 각 노드의 2^k번째 조상 노드 저장 (희소 배열)
  - 두 노드의 깊이를 맞춘 후 공통 조상 찾기
- **시간 복잡도**: 
  - 전처리: O(N log N)
  - 쿼리: O(log N)
- **활용**: 트리에서 두 노드 간 경로 문제, 거리 계산 등

### Trie (트라이)
- **설명**: 문자열을 효율적으로 저장하고 검색하기 위한 트리 자료구조
- **특징**:
  - 각 노드는 문자 하나를 나타냄
  - 루트에서 리프까지의 경로가 하나의 문자열을 나타냄
  - 공통 접두사를 공유하는 문자열들이 같은 경로를 공유
- **시간 복잡도**:
  - 삽입: O(M) (M: 문자열 길이)
  - 검색: O(M)
- **활용**: 문자열 검색, 자동완성, 사전 등

---

## 참고 자료

- 도서: <이것이 코딩테스트다>